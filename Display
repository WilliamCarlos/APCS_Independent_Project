/**
 * 
 * @Authors
 * Ophir Sneh, Dean Leitersdorf, William Lee
 * 
 */

import java.awt.AWTException;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Robot;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.Collections;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;


public class Display extends JComponent implements MouseListener, MouseMotionListener {
	public double k = 9*Math.pow(10, 9);
	double permitivity_of_free_space = 8.85418782 * Math.pow(10, -12);
	public int DISPLAY_WIDTH;   
	public int DISPLAY_HEIGHT;
	private boolean paintloop = true;
	int TIME_BETWEEN_REPLOTS = 50;
	Ball[] ballarray;
	int xdif = 0;
	int ydif = 0;
	JFrame f;
	double volume;
	double lastvolume;
	double[] originalX = new double[100];
	double[] originalY = new double[100];
	private StartButton start;
	JLabel[] chargeDisplay;
	Force[][] electricField;
	double[][] voltageValue;

	//2000, 900
	int voltageBarLength = 300;
	int voltageBarWidth = 50;
	int voltageBarX;
	int voltageBarY;
	JLabel voltageBarMax;
	//JLabel voltageBarMid;
	JLabel voltageBarMin;

	String voltageOnMouse = "";
	int pixel =7;

	int timeCounter = -TIME_BETWEEN_REPLOTS;



	public Display(int width, int height, JFrame frame) {
		this.DISPLAY_WIDTH = width;
		this.DISPLAY_HEIGHT = height; 
		this.voltageBarX = DISPLAY_WIDTH/20;
		this.voltageBarY = DISPLAY_HEIGHT/6 + DISPLAY_HEIGHT/100;
		this.electricField = new Force[DISPLAY_WIDTH][DISPLAY_HEIGHT];
		this.voltageValue = new double[DISPLAY_WIDTH][DISPLAY_HEIGHT];

		f = frame; 
		init();
	}

	public void init() {
		setSize(DISPLAY_WIDTH, DISPLAY_HEIGHT);
		paintloop = true;
		start = new StartButton();
		start.setBounds(DISPLAY_HEIGHT/9, DISPLAY_WIDTH/20, 100, 50);
		add(start);
		start.setVisible(true);
		ballarray = new Ball[7];
		chargeDisplay = new JLabel[ballarray.length];
		addMouseListener(this);
		addMouseMotionListener(this);


		voltageBarMax = new JLabel("MAX");
		voltageBarMax.setBounds(voltageBarX + 55, voltageBarY-25, 50, 75);
		add(voltageBarMax);
		voltageBarMax.setVisible(true);

		voltageBarMin = new JLabel("MIN");
		voltageBarMin.setBounds(voltageBarX + 55, voltageBarY + voltageBarLength-50, 50, 75);
		add(voltageBarMin);
		voltageBarMin.setVisible(true);

	Ball ball;
		for (int i = 0; i<1; i++) {
			for (int j = 0; j<6; j++) {

				ball = new Ball(15, DISPLAY_WIDTH/2-135+i*30, DISPLAY_HEIGHT/6+65+j*30, 0, 0, 0, Math.max((Math.random()*100/1000000), 200/1000000));
				ballarray[i*3+j] = ball;
				originalX[i*3+j] = ballarray[i*3+j].x;
				originalY[i*3+j] = ballarray[i*3+j].y;
				chargeDisplay[i*3+j] = new JLabel();
				JLabel temp = chargeDisplay[i*3+j];

				String str = "";
				str+=(int)(ball.charge*1000000);
				str+="µC";
				temp.setText(str);
				temp.setBounds((int)ball.x, (int)ball.y, 50, 25);
				add(temp);
			    temp.setVisible(true);


			}

		}

		ball = new Ball(10, DISPLAY_WIDTH/2-135+0*30, DISPLAY_HEIGHT/6+65+5*30, 0, 0, 0, -Math.max(Math.random()*100/1000000, 35/1000000));
		int a = 6;
		ballarray[a] = ball;
		originalX[a] = ballarray[a].x;
		originalY[a] = ballarray[a].y;
		chargeDisplay[a] = new JLabel();
		JLabel temp = chargeDisplay[a];
		String str = "";
		str+=(int)(ball.charge*1000000);
		str+="µC";
		temp.setText(str);
		temp.setBounds((int)ball.x, (int)ball.y, 50, 25);
		add(temp);
	    temp.setVisible(true);


		repaint();

	}

	public void paintComponent(Graphics g) {
		g.setColor(Color.BLACK);
		g.drawRect(DISPLAY_WIDTH/6, DISPLAY_HEIGHT/6, DISPLAY_WIDTH*2/3, DISPLAY_HEIGHT*5/6 - DISPLAY_HEIGHT/10);

		lastvolume=DISPLAY_WIDTH*DISPLAY_HEIGHT;
		xdif = f.getWidth()-DISPLAY_WIDTH;
		DISPLAY_WIDTH=f.getWidth();
		volume = DISPLAY_WIDTH*DISPLAY_HEIGHT;
		g.setColor(Color.BLUE);

		start.repaint();


		drawVoltageGrid(g);
		drawVoltageScale(g);


		((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,  RenderingHints.VALUE_ANTIALIAS_ON);
		if (paintloop) {
			try {
				Thread.sleep(TIME_BETWEEN_REPLOTS);
				timeCounter+=TIME_BETWEEN_REPLOTS;
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

			onloop(g);


			repaint();
		}

		for(int i = 0; i<ballarray.length; i++) {
			ballarray[i].draw(g);
		}

		repaint();
	}

	public void togglePaintLoop() {
		paintloop = !paintloop;
	}

	public void onloop(Graphics g) {
		for(int k = 0; k <ballarray.length; k++){
			Ball temp = ballarray[k];
			temp.force = new Force();
			for(int j = 0; j <ballarray.length; j++){
				if(k!=j){
					Ball temp2 = ballarray[j];
					temp.force.add(CalculateForce(ballarray[j], ballarray[k]));
					//System.out.println("Calced: " + j + " on: " + k);
				}
			}
		}

		for (int i = 0; i<ballarray.length; i++) {
			ballarray[i].update(g, DISPLAY_WIDTH, DISPLAY_HEIGHT, TIME_BETWEEN_REPLOTS);
			if (ballarray[i].hitWall == true) {
				if (xdif<0) {
					ballarray[i].x+=xdif;
				}
				if (ydif<0) {
					ballarray[i].y+=ydif;
				}
			}
			ballarray[i].draw(g);
			updateJLabel(chargeDisplay[i], i);

		}
		if (xdif!= 0 || ydif!=0) {
			for (int i = 0; i<ballarray.length; i++) {
				ballarray[i].speed*=Math.sqrt(lastvolume/volume);
			}
		}


		if(timeCounter%50==0){
		//calculateElectricFieldOnScreen();
		calculateVolateOnScreen();
		//printVoltages();

		}

		/*
		if(timeCounter%1000==0){
			updateVoltageScaleText();
		}
		*/

		printSigmaKineticEnergyAndElectric();

	}

	private void printSigmaKineticEnergyAndElectric() {
		double totE = 0;
		for(Ball b : ballarray){
			totE+=Math.pow(b.getSpeed() , 2)*b.mass*0.5;
		}

		for(int k = 0; k <ballarray.length; k++){


			Ball temp = ballarray[k];

			for(int j = 0; j <ballarray.length; j++){
				if(k!=j){
					Ball temp2 = ballarray[j];

					totE+=(CalculatePotentialEnergy(ballarray[j], ballarray[k]));

				}}}
		System.out.println(totE);

	}

	private double CalculatePotentialEnergy(Ball ball, Ball ball2) {

		return k*ball.charge*ball2.charge/distance(ball.x, ball2.x, ball.y, ball2.y);
	}

	private void updateVoltageScaleText(ArrayList<Double> list) {

		StringBuilder sb = new StringBuilder();
		sb.append("<html> Max: ");
		sb.append("<br>");
		try{
			Double n = list.get(list.size()-1);
			int numZerosToAdd = 0;
			if(n>=999){
				while(n>=10){
					n/=10;
					numZerosToAdd++;
				}
			}
			else if(n<.1){
				while(n<1){
					n*=10;
					numZerosToAdd--;
				}
			}
		sb.append(n.toString().substring(0, 5));

		if(numZerosToAdd!=0){
			sb.append("<br>");
			sb.append("E ");
			sb.append(numZerosToAdd);
		}


		}
		catch(IndexOutOfBoundsException e){

		}

		voltageBarMax.setText(sb.toString());


		sb = new StringBuilder();
		sb.append("<html> Min: ");
		sb.append("<br>");
		try{
			Double n = list.get(0);

			int numZerosToAdd = 0;
			if(Math.abs(n)>=999){
				while(Math.abs(n)>=10){
					n/=10;
					numZerosToAdd++;

				}
			}
			else if(Math.abs(n)<.1){
				while(Math.abs(n)<10){
					n*=10;
					numZerosToAdd--;


				}
			}
		sb.append(n.toString().substring(0, 5));

		if(numZerosToAdd!=0){
			sb.append("<br>");		
			sb.append("E ");
			sb.append(numZerosToAdd);
		}


		}
		catch(IndexOutOfBoundsException e){

		}

		voltageBarMin.setText(sb.toString());

	}

	private void printVoltages() {
		for(int x = 0; x <DISPLAY_WIDTH; x++){
			for (int y = 0; y < DISPLAY_HEIGHT; y++){
				double v = voltageValue[x][y];
				if (v!=0){
				//	System.out.println("X: " + x + " Y: " + y + " V: " + v);
				}
			}
		}

	}

	private void drawVoltageGrid(Graphics g) {
		ArrayList<Double> list = makeList(voltageValue);
		Collections.sort(list);
		double belowZero = getNegativeAmount(list);
		double exactlyZero  = getZeroAmount(list);
		double aboveZero = getPositiveAmount(list);



		for(int x = DISPLAY_WIDTH/6 +5; x < DISPLAY_WIDTH*5/6 -10; x+=pixel){
			for (int y = DISPLAY_HEIGHT/6+5; y <DISPLAY_HEIGHT*5/6 + DISPLAY_HEIGHT/10 -30; y+=pixel){
				double value = voltageValue[x][y];
				g.setColor(Color.black);
				int colorVal = 128;
				boolean hot = false;


				if(value<0){
					colorVal = (int)((belowZero - list.indexOf(value))/belowZero*128);
					colorVal = Math.min(colorVal, 128);
					hot = false;


				}else if(value>0){
					colorVal = (int)((list.indexOf(value)-belowZero+2)/aboveZero*128);
					colorVal = Math.min(colorVal, 128);
					hot = true;
				}

				if(!hot){
					g.setColor(new Color(128-colorVal, 0, colorVal+127));
				}
				else if(hot){
					g.setColor(new Color(colorVal+127, 0, 128-colorVal));
				}


				g.fillRect(x, y, 7, 7);
			}
			}

		updateVoltageScaleText(list);

	}



	private int getZeroAmount(ArrayList<Double> list) {
		int counter = 0;
		for(int i = 0; i < list.size(); i++){
			if(list.get(i)==0){
				counter++;
			}
		}
		return counter;
	}

	private int getPositiveAmount(ArrayList<Double> list) {
		int counter = 0;
		for(int i = 0; i < list.size(); i++){
			if(list.get(i)>0){
				counter++;
			}
		}
		return counter;
	}

	private int getNegativeAmount(ArrayList<Double> list) {
		int counter = 0;
		for(int i = 0; i < list.size(); i++){
			if(list.get(i)<0){
				counter++;
			}
		}
		return counter;
	}

	private ArrayList<Double> makeList(double[][] a) {
		ArrayList<Double> retval = new ArrayList<Double>();
		for(int i = 0; i < a.length; i++){
			for (int j = 0; j < a[i].length; j++){
				if(a[i][j]!=0){
					retval.add(a[i][j]);
				}
			}
		}

		return retval;
	}


	private void drawVoltageScale(Graphics g){
		int x = voltageBarX;
		int y = voltageBarY;
		int width = voltageBarWidth;
		int height = 1;
		double length = voltageBarLength/2;
		//For hot:
	for(double i = length; i >=0; i--){
		int colorVal = (int) (i/length*128);
		g.setColor(new Color(colorVal+127, 0, 128-colorVal));
		colorVal = Math.min(colorVal, 128);
		g.fillRect(x, (int) (y+length-i), width, height);
	}
	for(double i = 1; i <=length; i++){
		int colorVal = (int) (i/length*128);
		g.setColor(new Color(128-colorVal, 0, colorVal+127));
		colorVal = Math.min(colorVal, 128);
		g.fillRect(x, (int) (y+length+i), width, height);
	}


	}


	private void calculateVolateOnScreen() {
		for(int x = DISPLAY_WIDTH/6 +5; x < DISPLAY_WIDTH*5/6-10; x+=pixel){
			for (int y = DISPLAY_HEIGHT/6 +5; y <DISPLAY_HEIGHT*5/6 + DISPLAY_HEIGHT/10-30; y+=pixel){
				voltageValue[x][y] = 0;
				for(int i = 0; i <ballarray.length; i++){
					Ball ball = ballarray[i];
					voltageValue[x][y] += calculateVoltage(ball, new Point(x, y));
				}
			}
			}

	}

	private double calculateVoltage(Ball ball, Point point) {
		return ball.charge/distance(ball.x, ball.y, point.x, point.y)/(4*Math.PI*permitivity_of_free_space);

	}

	private double distance(double x, double y, double x2, double y2) {
		return Math.pow(Math.pow(x - x2, 2) + Math.pow(y - y2, 2), 0.5);

	}

	private void calculateElectricFieldOnScreen() {
		for(int x = DISPLAY_WIDTH/6+5; x < DISPLAY_WIDTH*5/6-10; x+=pixel){
			for (int y = DISPLAY_HEIGHT/6+5; y <DISPLAY_HEIGHT*5/6 + DISPLAY_HEIGHT/10-30; y+=pixel){
				electricField[x][y] = new Force();
				for(int i = 0; i <ballarray.length; i++){
					Ball ball = ballarray[i];

					electricField[x][y].add(
							calculateElectricField(ball,  new Point (x, y)));
				}
			}
		}

	}

	private Force calculateElectricField(Ball ball, Point point) {
		double magnitude = ball.charge*k;
		magnitude/=distanceSquared(ball, new Ball(0, point.x, point.y, 0, 0, 0, 0));
		// Only thing that matters for distanceSquared is the x and y coords, 
		//thus all the rest can be 0s.
		double theta = calculateTheta(ball, new Ball(0, point.x, point.y, 0, 0, 0, 0));
		return new Force(magnitude, theta);
	}

	private void updateJLabel(JLabel jLabel, int i) {
		String str = "";
		str+=(int)(ballarray[i].charge*1000000);
		str+="µC";
		jLabel.setText(str);
		jLabel.setBounds((int)ballarray[i].x, (int)ballarray[i].y, 50, 25);
		add(jLabel);
	    jLabel.setVisible(true);

	}

	public Force CalculateForce(Ball ballA, Ball ballB) {
		// TODO Auto-generated method stub
		double magnitude = Math.abs(ballA.charge) * Math.abs(ballB.charge);
		boolean attract = attract(ballA, ballB);
		magnitude *= k;
		double distSquare = distanceSquared(ballA, ballB);
		if(distSquare<100){
			distSquare=100;//This is in order to avoid massive accelerations.
		}
		magnitude /= distSquare;
		double theta = calculateTheta(ballA, ballB);
		if(!attract){
			theta+=Math.PI;
		}
		Force retval = new Force(magnitude, theta);
		return retval;
	}

	//calculates theta to calculate resultants
	private double calculateTheta(Ball b1, Ball b2) {
		// TODO Auto-generated method stub
		double theta = 0;
		double xComp = b1.x - b2.x;
		double yComp = b1.y - b2.y;
		if(xComp > 0) {
			theta = Math.atan(yComp/xComp);
			return theta;
		}else if(xComp < 0){
			theta =  Math.atan(yComp/xComp) + Math.PI;
			return theta;
		}
		else if(xComp == 0) {
			if(yComp == 0) {
				return 00;
			}else if (yComp > 0){
				return Math.PI/2;
			}else if(yComp < 0) {
				return 3*Math.PI/2;
			}
		}
		return theta;
	}

	private double calculateTheta2(Ball b1, Ball b2){
		return Math.atan2(b1.x-b2.x, b1.y-b2.y);
	}

	public boolean attract(Ball ballA, Ball ballB) {
		return ballA.charge * ballB.charge < 0;
	}

	public double distanceSquared(Ball b1, Ball b2) {
		return Math.pow(b1.x-b2.x, 2) + Math.pow(b1.y-b2.y, 2);
	}

	public void setPaintLoop(boolean value) {
		paintloop = value;
	}

	private class StartButton extends JButton implements ActionListener {
		StartButton() {
			super("Pause");
			addActionListener(this);
		}

		public void actionPerformed(ActionEvent arg0) {
			if(this.getText().equals("Start")) {
				togglePaintLoop();
				this.setText("Pause");
			} else {
				togglePaintLoop();
				this.setText("Start");
			}
		}
	}

	@Override
	public void mouseDragged(MouseEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void mouseMoved(MouseEvent a) {
		/*
		 * 
		 * temp commented out
		 * 		 


		int x = a.getX() +5;
		x-=x%pixel;
		int y = a.getY() +5;
		y-=y%pixel;
		//System.out.println (x + "," +y);

		//if(voltageValue[x-(x%7)+a][y-(y%7)+a]!=0){

			System.out.println(voltageValue[x+5][y] + "," + (x-2) + "," + (y));



			ArrayList<Double> list = makeList(voltageValue);
			Collections.sort(list);
			double belowZero = getNegativeAmount(list);
			double exactlyZero  = getZeroAmount(list);
			double aboveZero = getPositiveAmount(list);
			double value = voltageValue[x+5][y];
			int colorVal = 128;
			boolean hot = false;


			if(value<0){
				colorVal = (int)((belowZero - list.indexOf(value))/belowZero*128);
				colorVal = Math.min(colorVal, 128);
				hot = false;


			}else if(value>0){
				colorVal = (int)((list.indexOf(value)-belowZero+2)/aboveZero*128);
				colorVal = Math.min(colorVal, 128);
				hot = true;
			}

			if(!hot){
				System.out.println(new Color(128-colorVal, 0, colorVal+127));
				System.out.println("Us: " + list.indexOf(value) + " Zero: "+ belowZero);
			}
			else if(hot){
				System.out.println(new Color(colorVal+127, 0, 128-colorVal));
			}


		 */
	}

	@Override
	public void mouseClicked(MouseEvent a) {
		System.out.println("X: " + a.getX() + " Y: " + a.getY());

		try {
			//wtf is robot
			Robot robot = new Robot();
			System.out.println(robot.getPixelColor(a.getX(), a.getY()));
		} catch (AWTException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}


	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub

	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub

	}
}
